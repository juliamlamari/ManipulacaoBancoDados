---
title: "Desafio_09"
author: "Júlia Lamari"
format: 
  html:
    self-contained: true
editor: visual
---

```{r}
#install.packages(c("readr", "RSQLite"), dep=TRUE, type='win.binary')
```
```{r}
# Carregar pacotes necessários
library(readr)
library(RSQLite)
```


# DESAFIO 9

## QUESTÃO 1:

Crie um arquivo de banco de dados em SQLite chamado voos.sqlite3. (Dica: o comando dbConnect() se conecta num banco de dados se o arquivo apontado existir ou cria um novo, caso o arquivo não exista.)
```{r}
# Criar conexão com o banco de dados
# Se o arquivo não existir, ele será criado automaticamente
conn <- dbConnect(SQLite(), "voos.sqlite3")

# Verificar se a conexão foi feita
print(conn)
```


## QUESTÃO 2:

Leia os arquivos airlines.csv e airports.csv. Deposite o conteúdo de cada um destes arquivos nas tabelas, respectivamente, airlines e airports. Utilize o comando dbWriteTable() para isso.
```{r}
airlines <- read_csv("airlines.csv")
airports <- read_csv("airports.csv")

# Gravar no banco de dados em tabelas separadas
dbWriteTable(conn, "airlines", airlines, overwrite = TRUE)
dbWriteTable(conn, "airports", airports, overwrite = TRUE)

# Conferir quais tabelas existem agora no banco
dbListTables(conn)
```


## QUESTÃO 3:

Crie uma função chamada lerDados contendo 2 argumentos, input e pos. A função deve apresentar ao usuário uma mensagem de progresso da leitura do arquivo flights.csv (utilize o comando message()), aos moldes do apresentado abaixo. A função deve salvar apenas os vôos que partiram ou chegaram aos seguintes aeroportos BWI, MIA, SEA, SFO e JFK, numa tabela chamada flights. Observe que a função não deve retornar nada para o usuário, deve apenas gravar a tabela obtida do chunk no banco de dados. (Dica: utilize o comando dbWriteTable() e estude como o argumento append deve ser utilizado para permitir que os chunks intermediários sejam adicionados ao fim da tabela.)

```{r}
# Função para já selecionar as colunas desejadas
lerDados <- function(input, pos) {
  # Mensagem de progresso
  message("Leitura atingiu a linha ", pos)
  
  # Selecionar só as colunas de interesse
  input <- input[, c(
    "YEAR", "MONTH", "DAY", "AIRLINE", "FLIGHT_NUMBER",
    "ORIGIN_AIRPORT", "DESTINATION_AIRPORT", "ARRIVAL_DELAY"
  )]
  
  # Lista de aeroportos de interesse
  aeroportos_filtro <- c("BWI", "MIA", "SEA", "SFO", "JFK")
  
  # Filtrar apenas linhas com origem ou destino nesses aeroportos
  data_filtered <- input[
    input$ORIGIN_AIRPORT %in% aeroportos_filtro |
      input$DESTINATION_AIRPORT %in% aeroportos_filtro, 
  ]
  
  # Gravar no banco (append = TRUE para acumular os chunks)
  if (nrow(data_filtered) > 0) {
    dbWriteTable(conn, "flights", data_filtered, append = TRUE)
  }
  
  invisible(NULL)
}
```

## QUESTÃO 4:

Leia o arquivo flights.csv, restringindo-se às colunas YEAR, MONTH, DAY, AIRLINE, FLIGHT_NUMBER, ORIGIN_AIRPORT, DESTINATION_AIRPORT e ARRIVAL_DELAY, e aplique a função lerDados() criada acima. Observe, novamente, que a função lerDados() não retorna nada para o usuário. Por isso, a função de callback a ser utilizada é SideEffectChunkCallback\$new(). Leia 100 mil registros por vez.
```{r}
# Callback que usa a função lerDados
callback <- SideEffectChunkCallback$new(lerDados)

# Ler flights.csv em chunks de 100 mil linhas
read_csv_chunked(
  file = "flights.csv",
  callback = callback,
  chunk_size = 100000
)
```


## QUESTÃO 5:

Acesse o banco de dados e, por meio de uma chamada em SQL, apresente o tempo médio de atraso de chegada por aeroporto de destino, a sigla do aeroporto, o nome completo do aeroporto e o nome completo da companhia aérea. Ordene o resultado (na mesma chamada de SQL) por ordem decrescente deste atraso médio (i.e., o primeiro registro deve ser o aeroporto que tem o maior tempo de atraso na chegada). Atente para o fato de que o mesmo nome de coluna pode acontecer em diferentes tabelas.

```{r}
# Consulta SQL completa com JOINs nas outras tabelas
query <- "
SELECT 
    f.DESTINATION_AIRPORT as sigla_aeroporto,
    a.AIRPORT as nome_completo_aeroporto,
    al.AIRLINE as nome_completo_companhia,
    AVG(f.ARRIVAL_DELAY) AS media_atraso
FROM flights f
LEFT JOIN airports a ON f.DESTINATION_AIRPORT = a.IATA_CODE
LEFT JOIN airlines al ON f.AIRLINE = al.IATA_CODE
GROUP BY f.DESTINATION_AIRPORT, a.AIRPORT, al.AIRLINE
ORDER BY media_atraso DESC;
"

# Executar consulta no banco
results <- dbGetQuery(conn, query)

# Mostrar as primeiras linhas
head(results, 10)
```

## Desconecta e Salva a data:
```{r}
# Desconectando da conexão conn
dbDisconnect(conn)

# Salvando a data e o horário em que o html foi gerado
Sys.time()
```
