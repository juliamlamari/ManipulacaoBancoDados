---
title: "Manipulação de Dados com Julia"
subtitle: "Performance e Tipagem sem SQL"
author: "Eduardo Amorim - 277141, Bruno Shimooka - 277129 e Júlia Lamari - 277179"
format: 
  revealjs:
    scrollable: true
    code-line-numbers: true  # Adicionei para melhorar a visualização do código
editor: visual
execute:
  echo: true   
---

## Manipulação de dados

**O que é Manipulação de Dados?**

É o processo de transformar dados brutos ("raw data") em dados limpos e estruturados ("tidy data").

**As Ferramentas do Ecossistema:**

-   **Julia:** O pilar é o pacote `DataFrames.jl`. Focado em alta performance e consistência de tipos.
-   **R:** Utiliza o `tidyverse` (`dplyr`), famoso pela sua legibilidade.
-   **Python:** Utiliza o `pandas`, o padrão da indústria para Data Science.

Vamos explorar 4 etapas fundamentais da manipulação utilizando um banco de dados simulado de **Vendas de Varejo** (`vendas_sujas`).

### **1) Criação e Diagnóstico do Banco em Julia**

Instalação dos pacotes (caso não tenha): `import Pkg; Pkg.add(["DataFrames", "CSV", "Statistics", "Dates"])`

```{r}
library(JuliaCall)

# Só chame o setup sem caminho
julia_setup()
```

Para este exemplo, vamos criar o DataFrame diretamente no código para facilitar a reprodução, simulando a leitura de um arquivo CSV sujo.

```{julia}
using DataFrames, Statistics, Dates

# 1. Simulando a carga de dados brutos
df_vendas = DataFrame(
    id_venda = [1, 2, 3, 4, 5, 6],
    cpf_cliente = ["123.456.789-00", "987.654.321-11", "111.222.333-44", "555.666.777-88", "999.888.777-66", "000.111.222-33"],
    categoria = ["Eletronicos", "eletronics", "MOVEIS", "moveis", "JARDIM", "Eletronicos"],
    valor = [2500.0, 1200.0, 890.0, 450.0, 150.0, missing],
    data_venda = [Date(2023,1,15), Date(2023,1,16), missing, Date(2023,1,18), Date(2023,1,19), Date(2023,1,20)],
    desconto = [missing, 100.0, 50.0, missing, 0.0, missing]
)

# 2. "Espiar" os dados
println("--- Amostra de Dados Brutos ---")
first(df_vendas, 6)
```

Identificamos 3 problemas principais (os mesmos do exemplo em R):

1.  **Privacidade:** A coluna `cpf_cliente` expõe dados sensíveis.
2.  **Inconsistência:** A coluna `categoria` mistura maiúsculas e minúsculas ("Eletronicos" vs "eletronics").
3.  **Dados Faltantes (`missing`):** Temos ausência de dados em `valor`, `data_venda` e `desconto`.

------------------------------------------------------------------------

### **2) Limpeza Passo a Passo**

#### Passo 1: Seleção de Colunas

Vamos remover a coluna `cpf_cliente` para garantir o anonimato e focar nas métricas de vendas.

**Função:** `select()` **Modificador:** `Not()` (para excluir colunas específicas).

```{julia}
# Criamos 'df_limpo' selecionando tudo, EXCETO (Not) a coluna cpf_cliente
df_limpo = select(df_vendas, Not(:cpf_cliente))

println("--- Colunas Atuais ---")
names(df_limpo)
```

------------------------------------------------------------------------

#### Passo 2: Padronização de Texto

Precisamos corrigir a coluna `categoria`. Vamos converter tudo para maiúsculo e corrigir erros de digitação (ex: "ELETRONICS" em inglês para "ELETRONICOS").

**Função:** `transform()` **Auxiliar:** `ByRow()` (aplica a função linha por linha).

```{julia}
# 1. Converter tudo para MAIÚSCULO
df_limpo = transform(df_limpo, :categoria => ByRow(uppercase) => :categoria)

# 2. Corrigir 'ELETRONICS' para 'ELETRONICOS'
# Usamos uma função anônima: x -> x == "ERRO" ? "CORRETO" : x
df_limpo = transform(df_limpo, 
    :categoria => ByRow(x -> x == "ELETRONICS" ? "ELETRONICOS" : x) => :categoria
)

println("Categorias Padronizadas: ", unique(df_limpo.categoria))
```

------------------------------------------------------------------------

#### Passo 3: Filtragem

Vamos filtrar para analisar apenas as vendas da categoria "ELETRONICOS".

**Função:** `filter()` **Sintaxe:** `:coluna => condição`

```{julia}
# Filtrar onde categoria é igual a "ELETRONICOS"
vendas_eletronicos = filter(:categoria => ==("ELETRONICOS"), df_limpo)

println("Total de vendas filtradas: ", nrow(vendas_eletronicos))
first(vendas_eletronicos, 3)
```

------------------------------------------------------------------------

#### Passo 4: Tratamento de `missing` (Nulos)

Temos duas estratégias para os dados faltantes:

1.  **Críticos (`valor`, `data_venda`):** Sem eles a venda não existe contabilmente. Removemos a linha.
    -   **Função:** `dropmissing!`
2.  **Opcionais (`desconto`):** Se está vazio, assumimos que o desconto foi 0.
    -   **Função:** `coalesce` (substitui missing pelo valor padrão).

```{julia}
println("Linhas ANTES de limpar vazios: ", nrow(df_limpo))

# 1. Remover linhas se 'data_venda' OU 'valor' forem missing
# Passamos um vetor de colunas [:col1, :col2] para verificar
dropmissing!(df_limpo, [:data_venda, :valor])

println("Linhas DEPOIS de limpar vazios críticos: ", nrow(df_limpo))

# 2. Preencher missing na coluna 'desconto' com 0.0
# coalesce.(x, 0.0) aplica a substituição em cada elemento
df_limpo = transform(df_limpo, 
    :desconto => (x -> coalesce.(x, 0.0)) => :desconto
)

first(df_limpo, 5)
```

------------------------------------------------------------------------

### Resultado Final

Após todas as etapas, temos um DataFrame limpo, seguro e pronto para análise estatística ou ingestão em um Dashboard.

```{julia}
println("--- Estatísticas Finais ---")
describe(df_limpo)
```

Observe que a coluna `nmissing` (número de faltantes) agora é 0 para todas as variáveis numéricas e de data.

---
format: 
  revealjs:
    scrollable: true
editor: visual
execute:
  echo: true
---

# Estudo de Outros Casos

# Caso 1: Vendas

## Criação e Diagnóstico (Varejo)

Simulando a leitura de um arquivo CSV sujo de vendas.

```{julia}
using DataFrames, Statistics, Dates

# 1. Simulando a carga de dados brutos
df_vendas = DataFrame(
    id_venda = [1, 2, 3, 4, 5, 6],
    cpf_cliente = ["123.456.789-00", "987.654.321-11", "111.222.333-44", "555.666.777-88", "999.888.777-66", "000.111.222-33"],
    categoria = ["Eletronicos", "eletronics", "MOVEIS", "moveis", "JARDIM", "Eletronicos"],
    valor = [2500.0, 1200.0, 890.0, 450.0, 150.0, missing],
    data_venda = [Date(2023,1,15), Date(2023,1,16), missing, Date(2023,1,18), Date(2023,1,19), Date(2023,1,20)],
    desconto = [missing, 100.0, 50.0, missing, 0.0, missing]
)

println("--- Amostra Bruta ---")
first(df_vendas, 4)
```

## Limpeza: Seleção e Padronização

Passo 1 (Remover CPF) e Passo 2 (Corrigir Categoria).

```{julia}
# 1. Seleção: Remover CPF
df_limpo = select(df_vendas, Not(:cpf_cliente))

# 2. Padronização: Maiúsculo e Correção de Texto
df_limpo = transform(df_limpo, :categoria => ByRow(uppercase) => :categoria)

df_limpo = transform(df_limpo, 
    :categoria => ByRow(x -> x == "ELETRONICS" ? "ELETRONICOS" : x) => :categoria
)

first(df_limpo, 3)
```

## Limpeza: Filtragem e Nulos

Passo 3 (Filtrar Eletrônicos) e Passo 4 (Tratar Missing).

```{julia}
# 3. Filtrar Categoria
vendas_eletronicos = filter(:categoria => ==("ELETRONICOS"), df_limpo)

# 4. Tratamento de Nulos
# Crítico: Remove se não tem data ou valor
dropmissing!(df_limpo, [:data_venda, :valor])

# Opcional: Preenche desconto com 0.0
df_limpo = transform(df_limpo, 
    :desconto => (x -> coalesce.(x, 0.0)) => :desconto
)

println("--- Dados Limpos ---")
first(df_limpo, 3)
```

# Caso 2: RH

## Cenário: Folha de Pagamento

Recebemos dados de funcionários para calcular a folha. Problemas: Nomes desnecessários, departamentos bagunçados e bônus vazios.

```{julia}
# Simulando a carga de dados de RH
df_rh = DataFrame(
    id_func = [101, 102, 103, 104, 105, 106],
    nome_completo = ["Ana Souza", "Carlos Lima", "Beatriz Rocha", "Daniel Silva", "Elena T.", "Fabio P."],
    departamento = ["TI", "ti", "Vendas", "vendas", "Recursos Humanos", "TI"],
    salario_base = [8000.0, 8200.0, 4500.0, 4500.0, 6000.0, missing],
    bonus_anual = [1000.0, missing, 500.0, missing, missing, 2000.0],
    data_admissao = [Date(2020,5,10), Date(2021,3,15), Date(2022,1,10), Date(2019,11,20), Date(2023,2,1), Date(2021,6,30)]
)

println("--- Folha Bruta ---")
first(df_rh, 4)
```

## Passo 1: Anonimização

Removemos o nome do funcionário, mantendo apenas o ID.

```{julia}
# Removemos a coluna de identificação pessoal 
df_rh_limpo = select(df_rh, Not(:nome_completo))  

println("Colunas Atuais: ", names(df_rh_limpo)) 
```

## Passo 2: Tratamento de Nulos

Tratamos os nulos **antes** de calcular novas colunas para evitar erros na soma.

```{julia}
# 1. Crítico: Removemos quem não tem salário base
dropmissing!(df_rh_limpo, :salario_base)

# 2. Opcional: Substituímos bonus 'missing' por 0.0
df_rh_limpo = transform(df_rh_limpo, 
    :bonus_anual => (x -> coalesce.(x, 0.0)) => :bonus_anual
)

first(df_rh_limpo, 3)
```

## Passo 3: Padronização Avançada

Usamos uma função personalizada para padronizar e abreviar "Recursos Humanos" para "RH".

```{julia}
# Função auxiliar
function limpar_depto(dep)
    d = uppercase(dep)
    return d == "RECURSOS HUMANOS" ? "RH" : d
end

# Aplicamos a transformação linha a linha
df_rh_limpo = transform(df_rh_limpo, 
    :departamento => ByRow(limpar_depto) => :departamento
)

println("Deptos Únicos: ", unique(df_rh_limpo.departamento))
```

## Passo 4: Engenharia de Atributos

Criamos a coluna `remuneracao_total` somando salário e bônus.

```{julia}
# Criar coluna somando salario_base e bonus_anual
df_rh_limpo = transform(df_rh_limpo, 
    [:salario_base, :bonus_anual] => ByRow(+) => :remuneracao_total
)

println("--- Folha Final ---")
first(df_rh_limpo, 5)
```

## Resumo das Diferenças dos Casos

Neste segundo exemplo, utilizamos técnicas diferentes:

1.  **Função Personalizada:** Criamos `limpar_depto` com lógica `if/else` própria.
2.  **Operação Matemática:** Usamos `ByRow(+)` para somar colunas, criando dados novos.
3.  **Fluxo:** Tratamos nulos *antes* da soma para garantir integridade matemática.

## Comparativo: Julia vs. R vs. Python

Abaixo, comparamos como realizar as mesmas tarefas nas três linguagens.

### 1. Seleção (Remover Coluna)

-   **Julia:** `select(df, Not(:coluna))`
    -   *Destaque:* Uso explícito de tipos (`:símbolos`) e lógica (`Not`).
-   **R (dplyr):** `select(df, -coluna)`
    -   *Destaque:* Extremamente conciso com o sinal de menos.
-   **Python (pandas):** `df.drop(columns=['coluna'])`
    -   *Destaque:* Verbo `drop` específico, diferente de `select`.

### 2. Padronização (Transformação)

-   **Julia:** `transform(df, :col => ByRow(func) => :col)`
    -   *Destaque:* Sintaxe "origem =\> função =\> destino". Clara, mas verbosa.
-   **R (dplyr):** `mutate(df, col = func(col))`
    -   *Destaque:* Parece uma atribuição de variável normal. Muito legível.
-   **Python:** `df['col'] = df['col'].apply(func)`
    -   *Destaque:* Atribuição direta de vetor.

### 3. Tratamento de Nulos

-   **Julia:** `dropmissing(df)` e `coalesce.(col, 0)`
    -   *Destaque:* `missing` é um tipo de dado nativo poderoso em Julia (Three-valued logic).
-   **R:** `drop_na(df)` e `replace_na()`
    -   *Destaque:* Funções auxiliares do pacote `tidyr` que facilitam muito.
-   **Python:** `df.dropna()` e `df.fillna(0)`
    -   *Destaque:* Métodos diretos do objeto DataFrame.

### Resumo de Performance vs Facilidade

| Linguagem  | Facilidade de Escrita  | Performance (Grandes Volumes) |
|:-----------|:----------------------:|:-----------------------------:|
| **R**      | ⭐⭐⭐⭐⭐ (Excelente) |         ⭐⭐⭐ (Bom)          |
| **Python** |  ⭐⭐⭐⭐ (Muito Bom)  |         ⭐⭐⭐ (Bom)          |
| **Julia**  |  ⭐⭐⭐ (Curva maior)  |   ⭐⭐⭐⭐⭐ (Excepcional)    |

**Conclusão:** Julia exige uma sintaxe um pouco mais rigorosa (`:símbolos`, `ByRow`, `!`), mas recompensa com velocidade de execução próxima a C/C++, ideal para *Big Data* sem necessidade de otimizações complexas.
