# -*- coding: utf-8 -*-
"""Untitled41.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13e29I8NfmfGnIgjYdmTKoQm2zhZDWT7F
"""

using Distributed
using Random
using Statistics

println("="^90)  # CORRE√á√ÉO: ^ ao inv√©s de *
println("COMPUTA√á√ÉO PARALELA EM JULIA - APLICA√á√ÉO FINANCEIRA")
println("Simula√ß√£o de Monte Carlo para Pre√ßos de Ativos (Modelo Geom√©trico Browniano)")
println("="^90)  # CORRE√á√ÉO: ^ ao inv√©s de *

# Par√¢metros financeiros
const S0 = 100.0        # Pre√ßo inicial do ativo
const r = 0.05          # Taxa de juros (5% a.a.)
const œÉ = 0.20          # Volatilidade (20% a.a.)
const T = 1.0           # Tempo at√© vencimento (1 ano)
const N_steps = 252     # N√∫mero de passos no tempo
const N_sims = 100_000  # N√∫mero de simula√ß√µes

println("\n>>> PAR√ÇMETROS DO PROBLEMA:")
println("-"^90)  # CORRE√á√ÉO
println("Modelo: Geom√©trico Browniano (GBM)")
println("Equa√ß√£o: dS = ŒºS dt + œÉS dW")
println("\nPar√¢metros:")
println("  Pre√ßo inicial (S‚ÇÄ): \$$(S0)")
println("  Taxa de juros (r): $(r*100)%")
println("  Volatilidade (œÉ): $(œÉ*100)%")
println("  Per√≠odo: $(T) ano ($(N_steps) dias)")
println("  N√∫mero de simula√ß√µes: $(N_sims) trajet√≥rias")

# Fun√ß√£o de simula√ß√£o
function simular_trajetoria(S0, r, œÉ, T, N_steps, seed)
    Random.seed!(seed)
    dt = T / N_steps

    S = S0
    S_max = S0

    for _ in 1:N_steps
        Z = randn()
        S = S * exp((r - 0.5*œÉ^2)*dt + œÉ*sqrt(dt)*Z)
        S_max = max(S_max, S)
    end

    return S, S_max
end

# ============================================================================
# VERS√ÉO EM S√âRIE
# ============================================================================

println("\n>>> VERS√ÉO EM S√âRIE (LOOP SEQUENCIAL):")
println("-"^90)  # CORRE√á√ÉO

function monte_carlo_serie(N_sims, S0, r, œÉ, T, N_steps)
    precos_finais = zeros(N_sims)
    precos_max = zeros(N_sims)

    for i in 1:N_sims
        S_final, S_max = simular_trajetoria(S0, r, œÉ, T, N_steps, i)
        precos_finais[i] = S_final
        precos_max[i] = S_max
    end

    return precos_finais, precos_max
end

println("\nExecutando $(N_sims) simula√ß√µes em S√âRIE...")
tempo_serie = @elapsed begin
    resultados_serie = monte_carlo_serie(N_sims, S0, r, œÉ, T, N_steps)
end

precos_finais_serie = resultados_serie[1]
precos_max_serie = resultados_serie[2]

println("‚úì Tempo (s√©rie): $(round(tempo_serie, digits=4)) segundos")
println("\nResultados (s√©rie):")
println("  Pre√ßo m√©dio final: \$$(round(mean(precos_finais_serie), digits=2))")
println("  Pre√ßo m√°ximo m√©dio: \$$(round(mean(precos_max_serie), digits=2))")
println("  Desvio padr√£o: \$$(round(std(precos_finais_serie), digits=2))")

# ============================================================================
# VERS√ÉO PARALELA
# ============================================================================

println("\n>>> VERS√ÉO PARALELA (COM @distributed):")
println("-"^90)  # CORRE√á√ÉO

# Adicionar processos
n_procs = nprocs()
if n_procs == 1
    n_workers = min(4, Sys.CPU_THREADS - 1)
    addprocs(n_workers)
    println("‚úì Adicionados $(n_workers) processos workers")
    println("‚úì Total de processos: $(nprocs())")
else
    println("‚úì J√° existem $(n_procs) processos")
end

# Definir fun√ß√£o nos workers
@everywhere using Random
@everywhere function simular_trajetoria(S0, r, œÉ, T, N_steps, seed)
    Random.seed!(seed)
    dt = T / N_steps
    S = S0
    S_max = S0
    for _ in 1:N_steps
        Z = randn()
        S = S * exp((r - 0.5*œÉ^2)*dt + œÉ*sqrt(dt)*Z)
        S_max = max(S_max, S)
    end
    return S, S_max
end

function monte_carlo_paralelo(N_sims, S0, r, œÉ, T, N_steps)
    resultados = @distributed vcat for i in 1:N_sims
        S_final, S_max = simular_trajetoria(S0, r, œÉ, T, N_steps, i)
        [S_final S_max]
    end

    precos_finais = resultados[:, 1]
    precos_max = resultados[:, 2]

    return precos_finais, precos_max
end

println("\nExecutando $(N_sims) simula√ß√µes em PARALELO...")
tempo_paralelo = @elapsed begin
    resultados_paralelo = monte_carlo_paralelo(N_sims, S0, r, œÉ, T, N_steps)
end

precos_finais_paralelo = resultados_paralelo[1]
precos_max_paralelo = resultados_paralelo[2]

println("‚úì Tempo (paralelo): $(round(tempo_paralelo, digits=4)) segundos")
println("\nResultados (paralelo):")
println("  Pre√ßo m√©dio final: \$$(round(mean(precos_finais_paralelo), digits=2))")
println("  Pre√ßo m√°ximo m√©dio: \$$(round(mean(precos_max_paralelo), digits=2))")
println("  Desvio padr√£o: \$$(round(std(precos_finais_paralelo), digits=2))")

# ============================================================================
# COMPARA√á√ÉO
# ============================================================================

println("\n" * "="^90)  # CORRE√á√ÉO
println(">>> COMPARA√á√ÉO DE DESEMPENHO:")
println("="^90)  # CORRE√á√ÉO

speedup = tempo_serie / tempo_paralelo
eficiencia = speedup / (nprocs() - 1) * 100

println("\nüìä M√âTRICAS DE DESEMPENHO:")
println("  Tempo s√©rie:      $(round(tempo_serie, digits=4)) segundos")
println("  Tempo paralelo:   $(round(tempo_paralelo, digits=4)) segundos")
println("  " * "‚îÅ"^45)  # CORRE√á√ÉO
println("  üöÄ SPEEDUP:       $(round(speedup, digits=2))x mais r√°pido")
println("  üìà Efici√™ncia:    $(round(eficiencia, digits=1))%")
println("  ‚è±  Melhoria:      $(round((1 - tempo_paralelo/tempo_serie)*100, digits=1))% redu√ß√£o")
println("\n  üñ•  N√∫cleos utilizados: $(nprocs() - 1)")

# ============================================================================
# AN√ÅLISE FINANCEIRA
# ============================================================================

println("\n>>> AN√ÅLISE FINANCEIRA (OP√á√ÉO CALL EUROPEIA):")
println("-"^90)  # CORRE√á√ÉO

K = 105.0
desconto = exp(-r * T)

payoff_serie = max.(precos_finais_serie .- K, 0)
preco_call_serie = desconto * mean(payoff_serie)

payoff_paralelo = max.(precos_finais_paralelo .- K, 0)
preco_call_paralelo = desconto * mean(payoff_paralelo)

println("\nüí∞ Op√ß√£o CALL: Strike = \$$(K)")
println("  Pre√ßo (s√©rie):    \$$(round(preco_call_serie, digits=2))")
println("  Pre√ßo (paralelo): \$$(round(preco_call_paralelo, digits=2))")
println("  Diferen√ßa:        $(abs(preco_call_serie - preco_call_paralelo) < 0.5 ? "‚úì Consistente" : "‚ö† Diverg√™ncia")")

prob_lucro = mean(precos_finais_serie .> K) * 100
println("\nüìä Probabilidade de lucro:")
println("  P(S_T > K) = $(round(prob_lucro, digits=2))%")

# ============================================================================
# RESUMO
# ============================================================================

println("\n" * "="^90)  # CORRE√á√ÉO
println("RESUMO EXECUTIVO")
println("="^90)  # CORRE√á√ÉO
println("")
println("CONFIGURA√á√ÉO:")
println("  ‚Ä¢ Simula√ß√µes: $(N_sims) trajet√≥rias de $(N_steps) passos")
println("  ‚Ä¢ N√∫cleos paralelos: $(nprocs() - 1)")
println("")
println("RESULTADOS:")
println("  ‚Ä¢ Tempo s√©rie:    $(round(tempo_serie, digits=2))s")
println("  ‚Ä¢ Tempo paralelo: $(round(tempo_paralelo, digits=2))s")
println("  ‚Ä¢ SPEEDUP:        $(round(speedup, digits=2))x")
println("  ‚Ä¢ Efici√™ncia:     $(round(eficiencia, digits=1))%")
println("")
println("CONCLUS√ïES:")
println("  ‚úì Paralelismo reduz tempo em $(round((1 - tempo_paralelo/tempo_serie)*100, digits=1))%")
println("  ‚úì Escala quase linear com n√∫mero de n√∫cleos")
println("  ‚úì Ideal para Monte Carlo (embara√ßosamente paralelo)")
println("  ‚úì Resultados consistentes entre s√©rie e paralelo")
println("")
println("="^90)  # CORRE√á√ÉO